
export const uniswapLitActionDescription = "A Lit Action that executes a token swap on Base using Uniswap V3. The AI must provide: tokenIn, tokenOut, amountIn";

export const uniswapLitAction = "(async () => {\n  const startTime = Date.now();\n  try {\n    console.log(\"Starting swap action...\", { time: 0 });\n    const ethersProvider = new ethers.providers.JsonRpcProvider(\n      chainInfo.rpcUrl\n    );\n    const UNISWAP_V3_QUOTER = \"0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a\";\n    const UNISWAP_V3_ROUTER = \"0x2626664c2603336E57B271c5C0b26F421741e481\";\n    const pkpEthBalance = await ethersProvider.getBalance(pkp.ethAddress);\n    console.log(\n      `Debug: PKP ETH balance on chain (${chainInfo.chainId}):`,\n      ethers.utils.formatEther(pkpEthBalance)\n    );\n    if (pkpEthBalance.eq(0)) {\n      console.warn(\"Warning: PKP has 0 ETH on this chain! It cannot pay gas.\");\n    }\n    const LIT_AGENT_REGISTRY_ABI = [\n      \"function getActionPolicy(address user, address pkp, string calldata ipfsCid) external view returns (bool isPermitted, bytes memory description, bytes memory policy)\"\n    ];\n    const LIT_AGENT_REGISTRY_ADDRESS = \"0x728e8162603F35446D09961c4A285e2643f4FB91\";\n    if (!LitAuth.authSigAddress) {\n      throw new Error(\"Missing required parameter: LitAuth.authSigAddress\");\n    }\n    if (!LitAuth.actionIpfsIds[0]) {\n      throw new Error(\"Missing required parameter: LitAuth.actionIpfsIds[0]\");\n    }\n    if (!pkp.ethAddress) {\n      throw new Error(\"Missing required parameter: pkp.ethAddress\");\n    }\n    const registryContract = new ethers.Contract(\n      LIT_AGENT_REGISTRY_ADDRESS,\n      LIT_AGENT_REGISTRY_ABI,\n      new ethers.providers.JsonRpcProvider(chainInfo.rpcUrl)\n    );\n    const [isPermitted, , policy] = await registryContract.getActionPolicy(\n      LitAuth.authSigAddress,\n      pkp.ethAddress,\n      LitAuth.actionIpfsIds[0]\n    );\n    if (!isPermitted) {\n      throw new Error(\"Action not permitted for this PKP\");\n    }\n    const policyStruct = [\"tuple(uint256 maxAmount, address[] allowedTokens)\"];\n    let decodedPolicy;\n    try {\n      decodedPolicy = ethers.utils.defaultAbiCoder.decode(policyStruct, policy)[0];\n      if (!decodedPolicy.maxAmount || !decodedPolicy.allowedTokens) {\n        throw new Error(\"Invalid policy format: missing required fields\");\n      }\n      try {\n        ethers.BigNumber.from(decodedPolicy.maxAmount);\n      } catch {\n        throw new Error(\"Invalid policy format: maxAmount is not a valid number\");\n      }\n      if (!Array.isArray(decodedPolicy.allowedTokens)) {\n        throw new Error(\"Invalid policy format: allowedTokens is not an array\");\n      }\n      decodedPolicy.allowedTokens = decodedPolicy.allowedTokens.map((token) => {\n        if (!ethers.utils.isAddress(token)) {\n          throw new Error(\n            `Invalid policy format: ${token} is not a valid address`\n          );\n        }\n        return ethers.utils.getAddress(token);\n      });\n    } catch (error) {\n      throw new Error(\n        `Failed to decode policy: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n    const normalizedTokenIn = ethers.utils.getAddress(params.tokenIn);\n    const normalizedTokenOut = ethers.utils.getAddress(params.tokenOut);\n    if (!decodedPolicy.allowedTokens.includes(normalizedTokenIn)) {\n      throw new Error(`Token not allowed: ${normalizedTokenIn}`);\n    }\n    if (!decodedPolicy.allowedTokens.includes(normalizedTokenOut)) {\n      throw new Error(`Token not allowed: ${normalizedTokenOut}`);\n    }\n    console.log(\"Getting token info...\", { time: Date.now() - startTime });\n    const tokenInterface = new ethers.utils.Interface([\n      \"function decimals() view returns (uint8)\",\n      \"function balanceOf(address account) view returns (uint256)\",\n      \"function approve(address spender, uint256 amount) external returns (bool)\"\n    ]);\n    const tokenInContract = new ethers.Contract(\n      params.tokenIn,\n      tokenInterface,\n      ethersProvider\n    );\n    const tokenInBalance = await tokenInContract.balanceOf(pkp.ethAddress);\n    const tokenOutContract = new ethers.Contract(\n      params.tokenOut,\n      tokenInterface,\n      ethersProvider\n    );\n    const decimalsIn = await tokenInContract.decimals();\n    const decimalsOut = await tokenOutContract.decimals();\n    console.log(\"Token decimals retrieved\", { time: Date.now() - startTime });\n    const amountIn = ethers.utils.parseUnits(params.amountIn, decimalsIn);\n    if (amountIn.gt(decodedPolicy.maxAmount)) {\n      throw new Error(`Amount exceeds policy limit. Max allowed: ${ethers.utils.formatUnits(decodedPolicy.maxAmount, decimalsIn)}`);\n    }\n    console.log(\"Checking balance...\", { time: Date.now() - startTime });\n    if (amountIn.gt(tokenInBalance)) {\n      throw new Error(\n        `Insufficient balance. PKP balance: ${ethers.utils.formatUnits(tokenInBalance, decimalsIn)}. Expected at least: ${ethers.utils.formatUnits(amountIn, decimalsIn)}`\n      );\n    }\n    console.log(\"Policy checks passed\", { time: Date.now() - startTime });\n    console.log(\"Starting quote process...\", { time: Date.now() - startTime });\n    let bestQuote = null;\n    let bestFee = null;\n    let expectedOut;\n    console.log(\"Debug: Attempting to call Uniswap quoter\");\n    const quoterInterface = new ethers.utils.Interface([\n      \"function quoteExactInputSingle((address tokenIn, address tokenOut, uint256 amountIn, uint24 fee, uint160 sqrtPriceLimitX96)) external returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)\"\n    ]);\n    const FEE_TIERS = [3e3, 500];\n    for (const fee of FEE_TIERS) {\n      try {\n        console.log(`Checking fee tier ${fee / 1e4}%...`, { time: Date.now() - startTime });\n        const quoteParams = {\n          tokenIn: params.tokenIn,\n          tokenOut: params.tokenOut,\n          amountIn,\n          fee,\n          sqrtPriceLimitX96: 0\n        };\n        const quote = await ethersProvider.call({\n          to: UNISWAP_V3_QUOTER,\n          data: quoterInterface.encodeFunctionData(\"quoteExactInputSingle\", [quoteParams])\n        });\n        const [amountOut] = quoterInterface.decodeFunctionResult(\"quoteExactInputSingle\", quote);\n        const currentQuote = ethers.BigNumber.from(amountOut);\n        if (!bestQuote || currentQuote.gt(bestQuote)) {\n          bestQuote = currentQuote;\n          bestFee = fee;\n          console.log(`Quote found: ${ethers.utils.formatUnits(currentQuote, decimalsOut)} @ ${fee / 1e4}%`, { time: Date.now() - startTime });\n        }\n      } catch (error) {\n        console.error(\"Debug: Quoter call failed for fee tier:\", fee, error);\n        continue;\n      }\n    }\n    if (!bestQuote) {\n      const error = new Error(\"No valid pool found for this token pair\");\n      console.error(\"Quote error:\", error);\n      throw error;\n    }\n    expectedOut = bestQuote;\n    console.log(`Best quote: ${ethers.utils.formatUnits(expectedOut, decimalsOut)} @ ${bestFee / 1e4}%`, { time: Date.now() - startTime });\n    const slippageTolerance = 5e-3;\n    const amountOutMin = expectedOut.mul(1e3 - slippageTolerance * 1e3).div(1e3);\n    console.log(\"Minimum output:\", ethers.utils.formatUnits(amountOutMin, decimalsOut));\n    const gasData = await Lit.Actions.runOnce(\n      { waitForResponse: true, name: \"gasPriceGetter\" },\n      async () => {\n        const provider = new ethers.providers.JsonRpcProvider(chainInfo.rpcUrl);\n        const baseFeeHistory = await provider.send(\"eth_feeHistory\", [\"0x1\", \"latest\", []]);\n        const baseFee = ethers.BigNumber.from(baseFeeHistory.baseFeePerGas[0]);\n        const nonce2 = await provider.getTransactionCount(pkp.ethAddress);\n        const priorityFee = baseFee.div(4);\n        const maxFee = baseFee.mul(2);\n        return JSON.stringify({\n          maxFeePerGas: maxFee.toHexString(),\n          maxPriorityFeePerGas: priorityFee.toHexString(),\n          nonce: nonce2\n        });\n      }\n    );\n    const parsedGasData = JSON.parse(gasData);\n    console.log(\"Gas data:\", {\n      maxFeePerGas: ethers.utils.formatUnits(parsedGasData.maxFeePerGas, \"gwei\"),\n      maxPriorityFeePerGas: ethers.utils.formatUnits(parsedGasData.maxPriorityFeePerGas, \"gwei\"),\n      nonce: parsedGasData.nonce\n    });\n    const maxFeePerGas = parsedGasData.maxFeePerGas;\n    const maxPriorityFeePerGas = parsedGasData.maxPriorityFeePerGas;\n    const totalGasCost = ethers.BigNumber.from(maxFeePerGas).add(ethers.BigNumber.from(maxPriorityFeePerGas));\n    const nonce = parsedGasData.nonce;\n    const ethBalance = await ethersProvider.getBalance(pkp.ethAddress);\n    if (ethBalance.lt(totalGasCost)) {\n      throw new Error(\n        `Insufficient ETH for gas. Have: ${ethers.utils.formatEther(ethBalance)} ETH. Need: ${ethers.utils.formatEther(totalGasCost)} ETH`\n      );\n    }\n    console.log(\"ETH balance:\", ethers.utils.formatEther(ethBalance), ethers.utils.formatEther(totalGasCost));\n    console.log(\"ETH balance sufficient for gas costs\", { time: Date.now() - startTime });\n    console.log(\"Gas and nonce retrieved\", {\n      time: Date.now() - startTime,\n      maxFeePerGas: ethers.utils.formatUnits(maxFeePerGas, \"gwei\") + \" gwei\",\n      maxPriorityFeePerGas: ethers.utils.formatUnits(maxPriorityFeePerGas, \"gwei\") + \" gwei\",\n      nonce\n    });\n    console.log(\"Preparing approval transaction...\", { time: Date.now() - startTime });\n    let approvalResponse;\n    let estimatedGasLimit;\n    try {\n      estimatedGasLimit = await tokenInContract.estimateGas.approve(\n        UNISWAP_V3_ROUTER,\n        amountIn,\n        { from: pkp.ethAddress }\n      );\n      console.log(\"Estimated gas limit for approval:\", estimatedGasLimit.toString());\n    } catch (gasEstimateError) {\n      console.error(\"Could not estimate gas. Using fallback gas limit of 300000.\", gasEstimateError);\n      estimatedGasLimit = ethers.BigNumber.from(\"300000\");\n    }\n    const approvalTx = {\n      to: params.tokenIn,\n      data: tokenInterface.encodeFunctionData(\"approve\", [\n        UNISWAP_V3_ROUTER,\n        amountIn\n      ]),\n      value: \"0x0\",\n      gasLimit: estimatedGasLimit.toHexString(),\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      chainId: chainInfo.chainId,\n      type: 2\n    };\n    console.log(\"Signing approval...\", { time: Date.now() - startTime });\n    const approvalSig = await Lit.Actions.signAndCombineEcdsa({\n      toSign: ethers.utils.arrayify(\n        ethers.utils.keccak256(ethers.utils.serializeTransaction(approvalTx))\n      ),\n      publicKey: pkp.publicKey,\n      sigName: \"erc20ApprovalSig\"\n    });\n    console.log(\"Signed approval:\", approvalSig);\n    const signedApprovalTx = ethers.utils.serializeTransaction(\n      approvalTx,\n      ethers.utils.joinSignature({\n        r: \"0x\" + JSON.parse(approvalSig).r.substring(2),\n        s: \"0x\" + JSON.parse(approvalSig).s,\n        v: JSON.parse(approvalSig).v\n      })\n    );\n    console.log(\"Signed approval transaction:\", signedApprovalTx);\n    console.log(\"Broadcasting approval...\", { time: Date.now() - startTime });\n    approvalResponse = await Lit.Actions.runOnce(\n      { waitForResponse: true, name: \"txnSender\" },\n      async () => {\n        try {\n          const provider = new ethers.providers.JsonRpcProvider(chainInfo.rpcUrl);\n          const approvalReceipt = await provider.sendTransaction(signedApprovalTx);\n          return approvalReceipt.hash;\n        } catch (error) {\n          console.error(\"Error sending approval:\", error);\n          throw error;\n        }\n      }\n    );\n    console.log(\"Waiting for approval confirmation...\", { time: Date.now() - startTime });\n    const approvalConfirmation = await ethersProvider.waitForTransaction(approvalResponse, 1);\n    if (approvalConfirmation.status === 0) {\n      throw new Error(\"Approval transaction failed\");\n    }\n    console.log(\"Approval transaction confirmed\", { time: Date.now() - startTime });\n    if (!ethers.utils.isHexString(approvalResponse)) {\n      throw new Error(`Invalid approval transaction hash: ${approvalResponse}`);\n    }\n    console.log(\"Preparing swap transaction...\", { time: Date.now() - startTime });\n    const routerInterface = new ethers.utils.Interface([\n      \"function exactInputSingle((address,address,uint24,address,uint256,uint256,uint160)) external payable returns (uint256)\"\n    ]);\n    let swapGasLimit;\n    try {\n      const routerContract = new ethers.Contract(\n        UNISWAP_V3_ROUTER,\n        routerInterface,\n        ethersProvider\n      );\n      swapGasLimit = await routerContract.estimateGas.exactInputSingle(\n        [params.tokenIn, params.tokenOut, bestFee, pkp.ethAddress, amountIn, amountOutMin, 0],\n        { from: pkp.ethAddress }\n      );\n      console.log(\"Estimated gas limit for swap:\", swapGasLimit.toString());\n      swapGasLimit = swapGasLimit.mul(120).div(100);\n    } catch (gasEstimateError) {\n      console.error(\"Could not estimate swap gas. Using fallback gas limit of 500000.\", gasEstimateError);\n      swapGasLimit = ethers.BigNumber.from(\"500000\");\n    }\n    const swapTx = {\n      type: 2,\n      // EIP-1559\n      to: UNISWAP_V3_ROUTER,\n      data: routerInterface.encodeFunctionData(\"exactInputSingle\", [\n        [params.tokenIn, params.tokenOut, bestFee, pkp.ethAddress, amountIn, amountOutMin, 0]\n      ]),\n      value: \"0x0\",\n      gasLimit: swapGasLimit.toHexString(),\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce: nonce + 1,\n      chainId: chainInfo.chainId,\n      type: 2\n    };\n    console.log(\"Signing swap...\", { time: Date.now() - startTime });\n    const swapSig = await Lit.Actions.signAndCombineEcdsa({\n      toSign: ethers.utils.arrayify(\n        ethers.utils.keccak256(ethers.utils.serializeTransaction(swapTx))\n      ),\n      publicKey: pkp.publicKey,\n      sigName: \"erc20SwapSig\"\n    });\n    const signedSwapTx = ethers.utils.serializeTransaction(\n      swapTx,\n      ethers.utils.joinSignature({\n        r: \"0x\" + JSON.parse(swapSig).r.substring(2),\n        s: \"0x\" + JSON.parse(swapSig).s,\n        v: JSON.parse(swapSig).v\n      })\n    );\n    console.log(\"Broadcasting swap...\", { time: Date.now() - startTime });\n    const swapResponse = await Lit.Actions.runOnce(\n      { waitForResponse: true, name: \"txnSender\" },\n      async () => {\n        try {\n          const provider = new ethers.providers.JsonRpcProvider(chainInfo.rpcUrl);\n          const swapReceipt = await provider.sendTransaction(signedSwapTx);\n          return swapReceipt.hash;\n        } catch (error) {\n          console.error(\"Error sending swap:\", error);\n          throw error;\n        }\n      }\n    );\n    if (!ethers.utils.isHexString(swapResponse)) {\n      throw new Error(`Invalid swap transaction hash: ${swapResponse}`);\n    }\n    Lit.Actions.setResponse({\n      response: JSON.stringify({\n        status: \"success\",\n        approvalHash: approvalResponse,\n        swapHash: swapResponse\n      })\n    });\n  } catch (error) {\n    console.error(\"Error:\", error);\n    Lit.Actions.setResponse({\n      response: JSON.stringify({\n        status: \"error\",\n        error: error.message\n      })\n    });\n  }\n})();";

export const uniswapMetadata = {
  uniswapLitAction: {
    IpfsHash: "Qme428Z8Eu8t2yuskdEhtdMSy4FKDh9EaJkH21pdBLT8qL",
    PinSize: 14861,
    Timestamp: "2024-12-20T06:14:42.922Z",
    isDuplicate: true,
    Duration: 0.867
  }
};

export * from "./policy";
