
export const sendERC20LitActionDescription = "A Lit Action that sends ERC-20 tokens. The AI must provide: tokenIn, recipientAddress, amountIn";

export const sendERC20LitAction = "(async () => {\n  try {\n    const ethersProvider = new ethers.providers.JsonRpcProvider(\n      chainInfo.rpcUrl\n    );\n    const LIT_AGENT_REGISTRY_ABI = [\n      \"function getActionPolicy(address user, address pkp, string calldata ipfsCid) external view returns (bool isPermitted, bytes memory description, bytes memory policy)\"\n    ];\n    const LIT_AGENT_REGISTRY_ADDRESS = \"0x728e8162603F35446D09961c4A285e2643f4FB91\";\n    if (!LitAuth.authSigAddress) {\n      throw new Error(\"Missing required parameter: LitAuth.authSigAddress\");\n    }\n    if (!LitAuth.actionIpfsIds[0]) {\n      throw new Error(\"Missing required parameter: LitAuth.actionIpfsIds[0]\");\n    }\n    if (!pkp.ethAddress) {\n      throw new Error(\"Missing required parameter: pkp.ethAddress\");\n    }\n    const registryContract = new ethers.Contract(\n      LIT_AGENT_REGISTRY_ADDRESS,\n      LIT_AGENT_REGISTRY_ABI,\n      ethersProvider\n    );\n    const [isPermitted, , policy] = await registryContract.getActionPolicy(\n      LitAuth.authSigAddress,\n      pkp.ethAddress,\n      LitAuth.actionIpfsIds[0]\n    );\n    if (!isPermitted) {\n      throw new Error(\"Action not permitted for this PKP\");\n    }\n    const policyStruct = [\"tuple(uint256 maxAmount, address[] allowedTokens, address[] allowedRecipients)\"];\n    let decodedPolicy;\n    try {\n      decodedPolicy = ethers.utils.defaultAbiCoder.decode(policyStruct, policy)[0];\n      if (!decodedPolicy.maxAmount || !decodedPolicy.allowedTokens || !decodedPolicy.allowedRecipients) {\n        throw new Error(\"Invalid policy format: missing required fields\");\n      }\n      decodedPolicy.allowedTokens = decodedPolicy.allowedTokens.map(\n        (token) => ethers.utils.getAddress(token)\n      );\n      decodedPolicy.allowedRecipients = decodedPolicy.allowedRecipients.map(\n        (recipient) => ethers.utils.getAddress(recipient)\n      );\n    } catch (error) {\n      throw new Error(\n        `Failed to decode policy: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n    const normalizedTokenAddress = ethers.utils.getAddress(params.tokenIn);\n    const normalizedRecipientAddress = ethers.utils.getAddress(params.recipientAddress);\n    if (!decodedPolicy.allowedTokens.includes(normalizedTokenAddress)) {\n      throw new Error(`Token not allowed: ${normalizedTokenAddress}`);\n    }\n    if (!decodedPolicy.allowedRecipients.includes(normalizedRecipientAddress)) {\n      throw new Error(`Recipient not allowed: ${normalizedRecipientAddress}`);\n    }\n    const tokenInterface = new ethers.utils.Interface([\n      \"function decimals() view returns (uint8)\",\n      \"function balanceOf(address account) view returns (uint256)\",\n      \"function transfer(address to, uint256 amount) external returns (bool)\"\n    ]);\n    const tokenContract = new ethers.Contract(\n      params.tokenIn,\n      tokenInterface,\n      ethersProvider\n    );\n    const [decimals, balance] = await Promise.all([\n      tokenContract.decimals(),\n      tokenContract.balanceOf(pkp.ethAddress)\n    ]);\n    const amount = ethers.utils.parseUnits(params.amountIn, decimals);\n    if (amount.gt(decodedPolicy.maxAmount)) {\n      throw new Error(\n        `Amount exceeds policy limit. Max allowed: ${ethers.utils.formatUnits(decodedPolicy.maxAmount, decimals)}`\n      );\n    }\n    if (amount.gt(balance)) {\n      throw new Error(\n        `Insufficient balance. PKP balance: ${ethers.utils.formatUnits(balance, decimals)}. Required: ${ethers.utils.formatUnits(amount, decimals)}`\n      );\n    }\n    const gasData = await Lit.Actions.runOnce(\n      { waitForResponse: true, name: \"gasPriceGetter\" },\n      async () => {\n        const provider = new ethers.providers.JsonRpcProvider(chainInfo.rpcUrl);\n        const baseFeeHistory = await provider.send(\"eth_feeHistory\", [\"0x1\", \"latest\", []]);\n        const baseFee = ethers.BigNumber.from(baseFeeHistory.baseFeePerGas[0]);\n        const nonce2 = await provider.getTransactionCount(pkp.ethAddress);\n        const priorityFee = baseFee.div(4);\n        const maxFee = baseFee.mul(2);\n        return JSON.stringify({\n          maxFeePerGas: maxFee.toHexString(),\n          maxPriorityFeePerGas: priorityFee.toHexString(),\n          nonce: nonce2\n        });\n      }\n    );\n    const parsedGasData = JSON.parse(gasData);\n    const { maxFeePerGas, maxPriorityFeePerGas, nonce } = parsedGasData;\n    let estimatedGasLimit;\n    try {\n      estimatedGasLimit = await tokenContract.estimateGas.transfer(\n        params.recipientAddress,\n        amount,\n        { from: pkp.ethAddress }\n      );\n      console.log(\"Estimated gas limit:\", estimatedGasLimit.toString());\n      estimatedGasLimit = estimatedGasLimit.mul(120).div(100);\n    } catch (error) {\n      console.error(\"Could not estimate gas. Using fallback gas limit of 100000.\", error);\n      estimatedGasLimit = ethers.BigNumber.from(\"100000\");\n    }\n    const transferTx = {\n      to: params.tokenIn,\n      data: tokenInterface.encodeFunctionData(\"transfer\", [\n        params.recipientAddress,\n        amount\n      ]),\n      value: \"0x0\",\n      gasLimit: estimatedGasLimit.toHexString(),\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      chainId: chainInfo.chainId,\n      type: 2\n    };\n    console.log(\"Signing transfer...\");\n    const transferSig = await Lit.Actions.signAndCombineEcdsa({\n      toSign: ethers.utils.arrayify(\n        ethers.utils.keccak256(ethers.utils.serializeTransaction(transferTx))\n      ),\n      publicKey: pkp.publicKey,\n      sigName: \"erc20TransferSig\"\n    });\n    const signedTransferTx = ethers.utils.serializeTransaction(\n      transferTx,\n      ethers.utils.joinSignature({\n        r: \"0x\" + JSON.parse(transferSig).r.substring(2),\n        s: \"0x\" + JSON.parse(transferSig).s,\n        v: JSON.parse(transferSig).v\n      })\n    );\n    console.log(\"Broadcasting transfer...\");\n    const transferHash = await Lit.Actions.runOnce(\n      { waitForResponse: true, name: \"txnSender\" },\n      async () => {\n        try {\n          const provider = new ethers.providers.JsonRpcProvider(chainInfo.rpcUrl);\n          const receipt = await provider.sendTransaction(signedTransferTx);\n          return receipt.hash;\n        } catch (error) {\n          console.error(\"Error sending transfer:\", error);\n          throw error;\n        }\n      }\n    );\n    if (!ethers.utils.isHexString(transferHash)) {\n      throw new Error(`Invalid transaction hash: ${transferHash}`);\n    }\n    Lit.Actions.setResponse({\n      response: JSON.stringify({\n        status: \"success\",\n        transferHash\n      })\n    });\n  } catch (error) {\n    console.error(\"Error:\", error);\n    Lit.Actions.setResponse({\n      response: JSON.stringify({\n        status: \"error\",\n        error: error.message\n      })\n    });\n  }\n})();";

export const sendERC20Metadata = {
  sendERC20LitAction: {
    IpfsHash: "Qmaso3dHHsoMuTHPiQQFtmut5J7EzHtuQ3KtkWMymhREEs",
    PinSize: 6737,
    Timestamp: "2024-12-20T06:49:49.328Z",
    isDuplicate: true,
    Duration: 0.697
  }
};

export * from "./policy";
